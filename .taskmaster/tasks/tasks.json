{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Project Scaffolding and Initialization",
        "description": "Set up the basic Go project structure, initialize Go modules, and create the initial directory layout for the CLI and daemon components.",
        "details": "Initialize a new Go module using `go mod init github.com/user/env-lease`. Create a standard Go project layout, for example: `/cmd/env-lease`, `/cmd/env-leased`, `/internal/config`, `/internal/daemon`, `/internal/ipc`, `/internal/provider`. Use a CLI framework like `cobra` to structure the commands.",
        "testStrategy": "Verify that the project builds successfully with `go build ./...`. No specific tests are needed for this setup task, but it enables all future testing.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Project Directory Structure",
            "description": "Establish the standard Go project layout by creating the `/cmd` and `/internal` directories along with their required subdirectories.",
            "dependencies": [],
            "details": "Based on the expansion guidance, create the following directory structure: `/cmd/env-lease`, `/cmd/env-leased`, `/internal/config`, `/internal/daemon`, `/internal/ipc`, and `/internal/provider`.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Cobra Root Command and Main Entrypoints",
            "description": "Create the main `cobra` root command and the `main.go` entrypoint files for both the CLI and daemon applications to provide a basic command structure.",
            "dependencies": [
              "1.1"
            ],
            "details": "Create a new file `/cmd/root.go` to define the main `cobra.Command`. Then, create `main.go` files within `/cmd/env-lease/` and `/cmd/env-leased/` that call the root command's `Execute()` function.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Finalize Project Structure by Removing Root main.go",
            "description": "Remove the temporary `main.go` file from the project root to complete the transition to the standard Go project structure.",
            "dependencies": [
              "1.2"
            ],
            "details": "Delete the `main.go` file located in the project's root directory. After removal, run `go build ./...` to verify that the project builds successfully with the new entrypoints in the `/cmd` directories.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 2,
        "title": "Configuration Parsing (`env-lease.toml`)",
        "description": "Implement the logic to parse the `env-lease.toml` configuration file into Go structs. This includes defining the structs for leases and handling different lease types, formats, and encodings.",
        "details": "Use a robust TOML parsing library like `github.com/BurntSushi/toml`. Define Go structs that map directly to the TOML structure. For example: `type Config struct { Leases map[string]Lease }`, `type Lease struct { Type string; Format string; Encoding string; Source string; Destination string; Duration string }`. Implement validation for required fields and default values (e.g., `lease_type` defaults to `\"env\"`).",
        "testStrategy": "Create a suite of unit tests with various valid and invalid `env-lease.toml` files. Test cases should include missing fields, invalid value types, different lease types (`env`, `file`), and custom formats/encodings.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Go Structs and Basic Parsing Logic",
            "description": "In a new package `internal/config`, define the Go structs (`Config`, `Lease`) that map to the `env-lease.toml` file structure. Implement a `Load(path string) (*Config, error)` function that uses the `github.com/BurntSushi/toml` library to parse a TOML file into these structs.",
            "dependencies": [],
            "details": "The `Config` struct should contain a map of leases, e.g., `Leases map[string]Lease`. The `Lease` struct should include fields like `Type`, `Format`, `Encoding`, `Source`, `Destination`, and `Duration`. The `Load` function will be the core entry point for configuration parsing.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Configuration Validation and Default Values",
            "description": "Enhance the configuration parsing logic to include validation for required fields and to set default values for optional fields. This ensures that the loaded configuration is always in a consistent and usable state.",
            "dependencies": [
              "2.1"
            ],
            "details": "After successfully parsing the TOML file into structs, iterate through the loaded leases. Validate that required fields (e.g., `Source`, `Destination`) are present. For optional fields like `Type`, set a default value (e.g., 'env') if it's not specified in the file. Return an error for any invalid or missing required configuration.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Develop Unit Tests for Configuration Parsing",
            "description": "Create a `config_test.go` file within the `internal/config` package to thoroughly test the parsing, validation, and default value logic.",
            "dependencies": [
              "2.1",
              "2.2"
            ],
            "details": "The test suite should cover multiple scenarios: a perfectly valid TOML file, a file with missing required fields (should error), a file with invalid data types, a file that relies on default values, and other edge cases. Use temporary files or in-memory strings to represent different TOML configurations for testing the `Load` function.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 3,
        "title": "Define SecretProvider Interface",
        "description": "Define a Go interface for abstracting the secret-fetching logic. This will allow for multiple secret backends to be implemented in the future.",
        "details": "In the `/internal/provider` package, define the interface. `type SecretProvider interface { Fetch(source string) (string, error) }`. The `source` string will be the provider-specific identifier for the secret (e.g., a 1Password secret reference URI).",
        "testStrategy": "This is an interface definition, so no direct tests are needed. The correctness will be validated by the tests for the concrete implementations.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement 1Password CLI Secret Provider",
        "description": "Create the first implementation of the `SecretProvider` interface that uses the 1Password CLI (`op`) to fetch secrets.",
        "details": "Create a `OnePasswordCLI` struct that implements the `SecretProvider` interface. The `Fetch` method will use the `os/exec` package to call `op read <source>`. It must handle potential errors, such as the `op` command not being in the PATH, the user not being logged in (which should result in a clear error message), or the secret not being found.",
        "testStrategy": "Unit test the provider by mocking `os/exec`. Create test cases for successful secret retrieval, `op` command not found, and `op` returning an error (e.g., locked vault). An integration test could be added that runs only if the `op` CLI is configured and available in the test environment.",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create OnePasswordCLI Struct and Basic Fetch Method",
            "description": "Set up the initial file structure and define the `OnePasswordCLI` struct, implementing a basic version of the `Fetch` method to execute the `op` command.",
            "dependencies": [],
            "details": "In the `internal/provider` package, create the `onepassword.go` file. Define the `OnePasswordCLI` struct and ensure it satisfies the `SecretProvider` interface. Implement the `Fetch` method to use `os/exec` to call `op read <source>` and capture its standard output. Basic error checking for the command execution itself should be included.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Robust Error Handling for CLI Interaction",
            "description": "Enhance the `Fetch` method to gracefully handle various failure modes specific to the `op` CLI, providing clear, user-friendly error messages for each case.",
            "dependencies": [
              "4.1"
            ],
            "details": "Expand the `Fetch` method to differentiate between different error conditions. Specifically, handle cases where: 1) the `op` executable is not found in the system's PATH; 2) the command returns a non-zero exit code (e.g., user not logged in, secret not found); 3) the command succeeds but produces no output. The function should return distinct and informative errors for each scenario.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Develop Unit Tests with Mocked Command Execution",
            "description": "Create a test suite for the `OnePasswordCLI` provider, using a mocking strategy for `os/exec` to simulate various outcomes of running the `op` command without an actual dependency on the CLI.",
            "dependencies": [
              "4.2"
            ],
            "details": "In `onepassword_test.go`, implement unit tests for the `Fetch` method. Use a mocking library or technique to replace the actual `os/exec.Command` execution. Create test cases to verify correct behavior for a successful secret retrieval, as well as for all the specific failure modes implemented in the previous subtask (command not found, non-zero exit code, empty output).",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 5,
        "title": "Implement IPC Framework with HMAC Security",
        "description": "Develop the shared communication layer for the CLI and daemon using a Unix Domain Socket. Implement HMAC signatures to ensure message authenticity and integrity.",
        "details": "Create an `/internal/ipc` package. Define message structs for commands (`GrantRequest`, `RevokeRequest`, `StatusRequest`) and responses. Use `net.Listen(\"unix\", socketPath)` for the server and `net.Dial(\"unix\", socketPath)` for the client. For security, generate a shared secret token. Each message should be serialized (e.g., JSON), and sent with an HMAC-SHA256 signature in a header or as part of the message envelope. Use the `crypto/hmac` and `crypto/sha256` standard libraries.",
        "testStrategy": "Create unit tests for the HMAC signing and verification logic. Write an integration test that starts a mock server and has a client send a message, verifying successful and authenticated communication.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define IPC Message Structs and HMAC Security Functions",
            "description": "Create the `/internal/ipc` package. Define the necessary message structs for requests (`GrantRequest`, `RevokeRequest`, `StatusRequest`) and their corresponding responses. Implement the core `Sign` and `Verify` functions using HMAC-SHA256 and a shared secret for message authentication.",
            "dependencies": [],
            "details": "This foundational subtask focuses on the data structures and cryptographic primitives. The `Sign` and `Verify` functions should be self-contained and unit-testable without requiring any networking code.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement IPC Server for Listening and Handling Messages",
            "description": "Create a `Server` struct within the `internal/ipc` package. Implement a `Listen` method that sets up a Unix Domain Socket listener. The server must accept incoming connections, read message data, use the `Verify` function from subtask 5.1 to check the HMAC signature, deserialize the message, and dispatch it to a registered handler.",
            "dependencies": [
              "5.1"
            ],
            "details": "The server implementation should handle the complete lifecycle of an incoming request, from accepting the raw connection to verifying its authenticity and preparing it for processing. Error handling for invalid signatures or malformed messages is critical.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement IPC Client for Sending Signed Messages",
            "description": "Create a `Client` struct in the `internal/ipc` package. Implement a `Send` method that connects to the daemon's Unix Domain Socket, serializes a given request message, signs it using the `Sign` function from subtask 5.1, and transmits it to the server. The client should also be capable of reading and deserializing the server's response.",
            "dependencies": [
              "5.1"
            ],
            "details": "This subtask encapsulates all client-side logic for communicating with the daemon. It will be the primary interface used by the CLI commands to send requests.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Write Integration Tests for Client-Server Communication",
            "description": "Develop a suite of integration tests to validate the end-to-end communication flow. The tests should start a mock server in a goroutine, use the client to send various signed messages, and verify that the server correctly processes valid messages and rejects tampered or invalid ones.",
            "dependencies": [
              "5.2",
              "5.3"
            ],
            "details": "These tests are crucial to ensure the entire framework is robust. Test cases should include successful communication, communication with an invalid HMAC signature, and handling of connection errors.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 6,
        "title": "Implement Atomic File Writer Utility",
        "description": "Create a utility function for performing atomic file writes. This ensures that destination files like `.envrc` are never left in a corrupted state.",
        "details": "Create a helper function, e.g., `AtomicWriteFile(filename string, data []byte, perm fs.FileMode)`. The logic should be: 1. Create a temporary file in the same directory using `os.CreateTemp`. 2. Write the data to the temporary file. 3. Close the temporary file. 4. Rename the temporary file to the final destination filename using `os.Rename`. This is an atomic operation on POSIX systems.",
        "testStrategy": "Unit test the utility using a temporary directory. Verify that the file is created with the correct content and permissions. Test edge cases like the destination directory not existing or permission errors during the rename.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement Daemon State Management",
        "description": "Implement the daemon's ability to persist the state of active leases to a JSON file, allowing it to resume operations after a restart.",
        "details": "Define a struct for the daemon's state, likely a map of lease identifiers to their expiration times and other metadata. Create `LoadState()` and `SaveState()` methods. The state file should be located at `~/.config/env-lease/state.json`. `LoadState()` should be called on daemon startup. `SaveState()` should be called whenever the set of active leases changes. Use `encoding/json` for serialization.",
        "testStrategy": "Unit test the `LoadState` and `SaveState` methods. Use a temporary file to verify that state is correctly written to and read from disk. Test edge cases like the state file not existing, being empty, or containing corrupted JSON.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define State Struct and Implement Save/Load Functions",
            "description": "In a new `internal/daemon` package, define the `State` struct to hold active lease data and implement the `LoadState(path string)` and `SaveState(path string)` functions for JSON serialization and file I/O.",
            "dependencies": [],
            "details": "The `State` struct should contain a map of lease identifiers to their metadata and expiration times. The `SaveState` function must ensure the target directory exists before writing the file. The `LoadState` function should handle cases where the file doesn't exist by returning a new, empty state object.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Create Unit Tests for State Persistence Logic",
            "description": "Write a comprehensive suite of unit tests for the `LoadState` and `SaveState` functions to ensure they are robust and handle all edge cases correctly.",
            "dependencies": [
              "7.1"
            ],
            "details": "Test cases must include: saving state and successfully loading it back; loading from a non-existent file (should result in a clean state); attempting to load from a file with corrupted JSON (should return an error); and verifying that `SaveState` correctly creates the directory structure if it's missing.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Integrate State Management into Daemon Lifecycle",
            "description": "Modify the main daemon logic to use the new state management functions, loading state on startup and saving state whenever the set of active leases is modified.",
            "dependencies": [
              "7.2"
            ],
            "details": "Call the `LoadState` function when the daemon process starts to restore any previously active leases from `~/.config/env-lease/state.json`. Hook the `SaveState` function into the parts of the code that grant, revoke, or otherwise modify leases to ensure the state on disk is always up-to-date.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 8,
        "title": "Implement Daemon Core Logic and Timer Loop",
        "description": "Build the main loop of the `env-leased` daemon. This loop will manage lease timers, trigger expirations, and handle the automatic revocation of secrets.",
        "details": "The daemon's main run loop will use a `time.Ticker` for periodic checks (e.g., every second). On each tick, it will iterate through the active leases from its state. If a lease's expiration time has passed, it will trigger the revocation logic (removing the line from the `.env` file or deleting the temp file). Upon startup, it should immediately check for and revoke any leases that expired while it was offline.",
        "testStrategy": "Unit test the core loop logic with a mocked clock (`time.After`) and a mock filesystem. Verify that leases are correctly identified as expired and that the revocation function is called. Test the startup logic to ensure it correctly handles leases that expired while the daemon was not running.",
        "priority": "high",
        "dependencies": [
          4,
          6,
          7
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Daemon Struct with Dependency Injection",
            "description": "Create the core `Daemon` struct in `internal/daemon`. This struct will hold the application state and dependencies, such as the state manager and secret revoker. Use interfaces for dependencies like the clock and filesystem to facilitate testing.",
            "dependencies": [],
            "details": "Define the `Daemon` struct with fields for a state manager, a secret revoker, and a clock interface (e.g., `type Clock interface { Now() time.Time; Ticker(d time.Duration) *time.Ticker }`). This sets up the foundation for dependency injection as specified in the expansion guidance.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Startup Revocation Check",
            "description": "Implement the logic that runs once when the daemon starts. This function will load the current lease state and immediately check for and revoke any leases that have already expired while the daemon was not running.",
            "dependencies": [
              "8.1"
            ],
            "details": "Within the `Run()` method, before the main loop begins, iterate through all leases loaded from the state. For each lease, compare its expiration time with the current time provided by the clock dependency. If expired, call the revocation logic. Ensure state is saved after this initial cleanup.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement Main Timer Loop with time.Ticker",
            "description": "Implement the main run loop for the daemon using a `time.Ticker`. This loop will periodically wake up (e.g., every second) to check the status of active leases and handle graceful shutdown signals.",
            "dependencies": [
              "8.1"
            ],
            "details": "In the `Run()` method, after the initial startup check, create a `time.Ticker` using the clock dependency. Use a `select` statement within a `for` loop to listen on the ticker's channel and a separate channel for shutdown signals (e.g., from an OS signal handler).",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement Lease Expiration Check and Revocation Trigger",
            "description": "Within the main timer loop, implement the logic to iterate through all active leases, check if their expiration time has passed, and trigger the revocation process for any that have expired.",
            "dependencies": [
              "8.2",
              "8.3"
            ],
            "details": "On each tick received from the `time.Ticker`, get the current list of active leases from the state manager. Iterate through them, comparing `lease.Expiration` with `clock.Now()`. If a lease is expired, call the injected secret revoker's `Revoke()` method and update the daemon's state by removing the lease.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 9,
        "title": "Implement Daemon IPC Server",
        "description": "Integrate the IPC framework into the daemon, allowing it to listen for and respond to commands from the `env-lease` CLI.",
        "details": "In the daemon's main function, start a goroutine that listens on the Unix Domain Socket defined in the IPC package. It should accept connections, read incoming messages, verify their HMAC signature, and dispatch them to handler functions (e.g., `handleGrant`, `handleRevoke`). The handlers will modify the daemon's state and trigger actions in the core loop.",
        "testStrategy": "Write integration tests where a mock client (from the IPC package tests) connects to a running instance of the daemon. Send `grant`, `revoke`, and `status` commands and verify that the daemon's internal state changes as expected.",
        "priority": "high",
        "dependencies": [
          5,
          8
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Integrate IPC Server into Daemon Struct and Run Loop",
            "description": "Modify the `Daemon` struct in `internal/daemon` to include an instance of the `ipc.Server`. In the `Run()` method, initialize the server and launch its `Listen()` method in a separate goroutine to begin accepting client connections.",
            "dependencies": [],
            "details": "Add a new field for the `ipc.Server` to the `Daemon` struct. Ensure the server is properly initialized during the daemon's setup. The call to `go d.ipcServer.Listen()` should be placed within the `Daemon.Run()` method, along with appropriate error handling if the server fails to start.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Thread-Safe State Handlers",
            "description": "Create the handler functions for grant, revoke, and status requests. These functions will modify the daemon's internal state. Introduce a `sync.Mutex` to the `Daemon` struct to ensure these state modifications are thread-safe.",
            "dependencies": [
              "9.1"
            ],
            "details": "Define a `sync.Mutex` in the `Daemon` struct. Implement `handleGrant`, `handleRevoke`, and `handleStatus` methods. Each method must acquire the lock before reading or writing to the daemon's state (e.g., the lease map) and release it afterward. The functions should accept request data and return a corresponding response object.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Register Handlers and Dispatch IPC Requests",
            "description": "Connect the IPC server's core loop to the handler functions. The server must be able to parse incoming requests, determine the command type, and dispatch the request to the correct handler.",
            "dependencies": [
              "9.2"
            ],
            "details": "The `ipc.Server` will need a mechanism to map request types to the handler methods on the `Daemon` instance. This could be a map or a switch statement within the connection handling loop. The server should pass the request payload to the handler and send the handler's response back to the client.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 10,
        "title": "Implement CLI IPC Client",
        "description": "Implement the client-side logic for the `env-lease` CLI to connect to the daemon, sign messages, and send commands.",
        "details": "Create a client struct in the `/internal/ipc` package that encapsulates dialing the socket, serializing a request, signing it with HMAC, sending it, and then reading and verifying the response. This client will be used by all CLI commands that need to interact with the daemon.",
        "testStrategy": "The client logic will be tested implicitly through the command implementation tests. Direct unit tests can be written to verify correct message formatting and signing.",
        "priority": "high",
        "dependencies": [
          5
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Core IPC Client Communication Logic",
            "description": "Create the basic `Client` struct in `/internal/ipc` and a core private method to handle the fundamental communication flow: dialing the daemon's socket, signing and sending a serialized request, and receiving/verifying the response. This method will be the foundation for all specific command requests.",
            "dependencies": [],
            "details": "This core method should handle the low-level details of establishing a connection, writing the signed payload, reading the response, and closing the connection. It will be used by the higher-level methods defined in the next subtask. Focus on robustly handling the raw byte stream and HMAC verification.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Develop High-Level, Command-Specific Client Methods",
            "description": "Implement public, high-level methods on the `ipc.Client` struct for each specific daemon command, such as `SendGrantRequest`, `SendRevokeRequest`, and `SendStatusRequest`. These methods will use the core communication logic from the first subtask.",
            "dependencies": [
              "10.1"
            ],
            "details": "Each method will be responsible for creating the appropriate request object, calling the core communication method, and then decoding the response into the correct type. Implement clear error wrapping to distinguish between connection errors (e.g., daemon not running) and application-level errors returned by the daemon.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 11,
        "title": "Implement `env-lease grant` Command",
        "description": "Build the `grant` command. This command will parse the configuration, communicate with the daemon to grant all defined leases, and handle user flags.",
        "details": "Using the `cobra` framework, create the `grant` command. It will first parse `env-lease.toml`. Then, it will use the IPC client to send a `GrantRequest` to the daemon containing the lease definitions. It must implement the `--override` and `--continue-on-error` flags, passing them along in the request. By default, the operation should be transactional ('all or nothing').",
        "testStrategy": "Write integration tests that execute the `grant` command against a mock daemon. Verify that the correct `GrantRequest` is sent. Test the default transactional behavior and the behavior when `--continue-on-error` is used.",
        "priority": "high",
        "dependencies": [
          2,
          10
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create `grant` Command Structure and Flags",
            "description": "In the `cmd` package, create a new file `grant.go`. Define the `cobra.Command` for the `grant` command and add the boolean flags for `--override` and `--continue-on-error`.",
            "dependencies": [],
            "details": "Create the file `cmd/grant.go`. Instantiate a `cobra.Command` struct for the `grant` command. Use `cmd.Flags().Bool()` to add the `--override` and `--continue-on-error` flags. Add a placeholder `RunE` function that will contain the core logic.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Load Configuration and Construct GrantRequest",
            "description": "Implement the logic within the `RunE` function to load the `env-lease.toml` configuration and use its contents, along with the command-line flags, to construct the `ipc.GrantRequest` message.",
            "dependencies": [
              "11.1"
            ],
            "details": "In the `grant` command's `RunE` function, call the appropriate function from the `config` package to load the `env-lease.toml` file. Handle any errors during loading. Create an instance of the `ipc.GrantRequest` struct and populate it with the lease definitions from the config and the flag values from the command.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement IPC Client Communication",
            "description": "Finalize the `RunE` function by creating an IPC client, sending the constructed `GrantRequest` to the daemon, and printing the response or any resulting error to the user.",
            "dependencies": [
              "11.2"
            ],
            "details": "Instantiate a new `ipc.Client`. Use the client to send the `GrantRequest` object created in the previous subtask to the running daemon. Check the response from the daemon and print a success message or the returned error to the console.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 12,
        "title": "Implement `env-lease revoke` Command",
        "description": "Build the `revoke` command, which allows a user to immediately revoke all active leases for the current project.",
        "details": "Create the `revoke` command using `cobra`. The command will use the IPC client to send a `RevokeRequest` to the daemon. The daemon will then be responsible for immediately revoking all leases associated with that project's configuration file.",
        "testStrategy": "Write an integration test. First, run `grant` to establish leases. Then, run `revoke` and query the mock daemon's state to verify that all leases have been removed.",
        "priority": "high",
        "dependencies": [
          10
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create `revoke` Command Structure with Cobra",
            "description": "Create the `revoke.go` file and define the basic `cobra.Command` for `env-lease revoke`. This includes setting up the command's name, description, and adding it to the root command.",
            "dependencies": [],
            "details": "In the `cmd` package, create a new file named `revoke.go`. Inside this file, define a `cobra.Command` struct for the `revoke` command. Set its `Use`, `Short`, and `Long` properties appropriately. Add a placeholder `RunE` function. Finally, ensure this new command is added to the root command so it's available in the CLI.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement IPC Logic to Send RevokeRequest",
            "description": "Implement the `RunE` function for the `revoke` command to communicate with the daemon. This involves creating an IPC client, constructing a `RevokeRequest`, sending it, and handling the response.",
            "dependencies": [
              "12.1"
            ],
            "details": "Within the `RunE` function of the `revoke` command, instantiate an `ipc.Client`. Construct a `RevokeRequest` message, ensuring it includes the path to the current project's configuration file. Use the client to send this request to the daemon. Based on the daemon's response, print a success message to stdout or the returned error to stderr.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 13,
        "title": "Implement `env-lease status` Command",
        "description": "Build the `status` command to display the state and remaining time for all active leases.",
        "details": "Create the `status` command using `cobra`. It will use the IPC client to send a `StatusRequest` to the daemon. The daemon will respond with a list of active leases and their remaining TTLs. The CLI will then format this information and print it to the console in a user-friendly table.",
        "testStrategy": "Write an integration test. Grant several leases with different durations, then run the `status` command. Capture the stdout and verify that it correctly displays the status and remaining time for each active lease.",
        "priority": "medium",
        "dependencies": [
          10
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create `status` command boilerplate in `cmd` package",
            "description": "Create a new file `cmd/status.go` and define the `cobra.Command` for the `status` command. This includes setting up the command's name, description, and adding it to the root command.",
            "dependencies": [],
            "details": "The file should be `cmd/status.go`. The command should be named `status`. The `RunE` function can be a placeholder initially. Ensure the new command is registered with the main `rootCmd`.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement IPC client call to fetch lease status",
            "description": "In the `RunE` function of the `status` command, instantiate the `ipc.Client` and use it to send a `StatusRequest` to the daemon. Handle the response and any potential errors from the IPC communication.",
            "dependencies": [
              "13.1"
            ],
            "details": "This involves using the existing `ipc.Client` to create and send a `StatusRequest`. The response from the daemon, which will contain the list of active leases, should be stored in a variable for the next step. Implement error handling for the client connection and request sending.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Format and print lease status using `tabwriter`",
            "description": "Using the lease status data received from the daemon, implement the output formatting. Use the `text/tabwriter` package to create a well-aligned, human-readable table that displays each lease's details, such as its destination and remaining TTL.",
            "dependencies": [
              "13.2"
            ],
            "details": "The table should have clear headers (e.g., 'Destination', 'Time Remaining'). The remaining TTL, received as a duration, should be formatted into a user-friendly string. The final formatted table should be printed to standard output.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 14,
        "title": "Implement Daemon Revocation Failure Handling",
        "description": "Implement the daemon's error handling logic for when a revocation operation fails. This includes periodic retries and creating a persistent failure notification file.",
        "details": "Modify the daemon's revocation logic. If revoking a secret fails (e.g., due to file permissions), the daemon should log the error and schedule a retry (e.g., using an exponential backoff strategy). If the failure persists for more than 5 minutes, the daemon must create a `.envrc.env-lease-REVOCATION-FAILURE` file in the project directory to alert the user.",
        "testStrategy": "Unit test this logic by mocking a revocation that always fails. Use a mock filesystem and a mock clock to verify that the retry mechanism is triggered and that the failure file is created after the specified duration.",
        "priority": "medium",
        "dependencies": [
          8
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Integrate a Retry Queue into the Daemon's State",
            "description": "Update the daemon's state management logic to include a new data structure for a 'retry queue'. This queue will hold leases that have failed revocation, tracking their details, the number of failed attempts, and the timestamp for the next scheduled retry. This new state must be persisted to disk along with the main lease state.",
            "dependencies": [],
            "details": "Define a new struct for a retry item containing the lease, attempt count, and next retry time. Add this structure to the main daemon state object. Modify the `SaveState()` and `LoadState()` functions to handle the serialization and deserialization of this new retry queue. When a revocation initially fails, move the lease from the active list to this queue.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Exponential Backoff Retry Mechanism",
            "description": "Develop the core logic within the daemon's main loop to process the retry queue. This mechanism will periodically check for leases due for a retry, attempt to revoke them, and reschedule them with an exponential backoff delay upon subsequent failures.",
            "dependencies": [
              "14.1"
            ],
            "details": "In the daemon's main processing loop, iterate through the retry queue. For each item, check if the current time is past its scheduled retry time. If so, attempt revocation. On success, remove the item from the queue. On failure, increment the attempt counter and calculate the next retry time using an exponential backoff formula (e.g., `base_delay * 2^attempts`), then update the item in the queue.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Create Persistent Failure Notification File",
            "description": "Enhance the retry logic to detect when a lease has been failing revocation for a cumulative period of more than 5 minutes. Upon detecting such a persistent failure, the daemon must use the atomic writer utility to create a `.envrc.env-lease-REVOCATION-FAILURE` file in the relevant project directory.",
            "dependencies": [
              "14.2"
            ],
            "details": "When a lease is first added to the retry queue, record the initial failure timestamp. Within the retry processing loop, check if the time elapsed since the initial failure exceeds 5 minutes for any given lease. If the threshold is crossed and the notification file does not already exist, create the file. Ensure this check is performed efficiently and the file is created only once per persistent failure.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 15,
        "title": "Implement Orphaned Lease Cleanup",
        "description": "Add logic to the daemon to automatically purge leases whose configuration file has been deleted, and add a manual cleanup command.",
        "details": "Add a periodic task to the daemon (e.g., runs daily) that checks if the `env-lease.toml` file for each active lease still exists. If a config file is missing, mark the lease as orphaned. If it remains orphaned for 30 days, revoke and delete it from the state. Also, add a hidden `env-leased --cleanup` command that allows a user to trigger this process manually.",
        "testStrategy": "Unit test the cleanup logic. Create a state file with several leases. Use a mock filesystem to 'delete' the config file for one of them. Advance a mock clock by 31 days and verify that the orphaned lease is removed from the state.",
        "priority": "low",
        "dependencies": [
          8
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Update Lease State Model for Orphan Tracking",
            "description": "Modify the daemon's lease state struct to include a new nullable timestamp field, `orphaned_since`. This field will track when a lease's configuration file was first detected as missing, which is essential for the 30-day cleanup logic.",
            "dependencies": [],
            "details": "The `orphaned_since` field should be added to the lease metadata struct managed by the state manager. The state loading and saving functions must be updated to correctly handle this new field, ensuring backward compatibility with existing state files if possible (e.g., by treating a missing field as not orphaned).",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Core Cleanup Logic Function",
            "description": "Develop a self-contained function within the daemon that performs the orphaned lease check. This function will iterate through all active leases, check for the existence of their corresponding `env-lease.toml` file, and update their state accordingly.",
            "dependencies": [
              "15.1"
            ],
            "details": "The function should perform two main actions: 1) For un-orphaned leases, check if the config file exists. If not, set the `orphaned_since` timestamp to the current time. 2) For already orphaned leases, check if `now() - orphaned_since > 30 days`. If true, revoke the lease's credentials and remove its entry from the daemon's state.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Integrate Cleanup Logic into Daemon and CLI",
            "description": "Wire the core cleanup function into the daemon's main loop for automatic execution and expose it via a manual CLI command.",
            "dependencies": [
              "15.2"
            ],
            "details": "First, add a long-interval ticker (e.g., every 24 hours) to the daemon's main event loop that calls the cleanup function. Second, add a hidden `env-leased --cleanup` command-line flag. When the daemon starts with this flag, it should execute the cleanup function once and then exit, providing a way for users or scripts to trigger the process manually.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 16,
        "title": "System Service Integration (launchd for macOS)",
        "description": "Create a `launchd` service file (`.plist`) and the necessary logic within the CLI to install, uninstall, and manage the daemon as a user agent on macOS.",
        "details": "Create a template for the `com.user.env-leased.plist` file. It should be configured to run as a user agent and keep the daemon running. Add commands like `env-lease daemon install` and `env-lease daemon uninstall` which will place/remove the plist file in `~/Library/LaunchAgents/` and use `launchctl` to load/unload it.",
        "testStrategy": "Manual testing on a macOS machine is required. Verify that `daemon install` correctly places the file and starts the service. Check `launchctl list | grep env-leased` to confirm it's running. Test that the service restarts automatically on login/reboot.",
        "priority": "medium",
        "dependencies": [
          9
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define launchd plist Template and Command Structure",
            "description": "Create the `com.user.env-leased.plist` template as a string constant or embedded file. Set up the basic structure for the `daemon` command and its `install`/`uninstall` subcommands in a new `cmd/daemon_darwin.go` file using Go build tags.",
            "dependencies": [],
            "details": "The plist template should be configured to run the daemon as a user agent and include the `KeepAlive` key to ensure it stays running. The command structure should be set up, but the core implementation logic will be in subsequent subtasks.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement `daemon install` Subcommand for macOS",
            "description": "Implement the logic for the `install` subcommand. This includes writing the populated `launchd` plist file to `~/Library/LaunchAgents/` and loading the service using `launchctl load`.",
            "dependencies": [
              "16.1"
            ],
            "details": "The implementation must dynamically determine the path to the current executable to correctly populate the `ProgramArguments` in the plist template. It will use `os/exec` to call `launchctl load <path-to-plist>`. Ensure robust error handling for file I/O and command execution.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement `daemon uninstall` Subcommand for macOS",
            "description": "Implement the logic for the `uninstall` subcommand. This involves unloading the service using `launchctl unload` and removing the `launchd` plist file from `~/Library/LaunchAgents/`.",
            "dependencies": [
              "16.1"
            ],
            "details": "The implementation will use `os/exec` to call `launchctl unload <path-to-plist>`. After successfully unloading the service, it should remove the plist file. It needs to handle cases where the file or service doesn't exist gracefully.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 17,
        "title": "System Service Integration (systemd for Linux)",
        "description": "Create a `systemd` service file and the CLI logic to manage the daemon as a user service on Linux.",
        "details": "Create a template for the `env-leased.service` file. It should be a user service (`--user`). Add `env-lease daemon install/uninstall` commands that place/remove the service file in `~/.config/systemd/user/` and use `systemctl --user` to enable, disable, start, and stop the service.",
        "testStrategy": "Manual testing on a Linux machine with systemd. Verify that `daemon install` works and the service starts. Use `systemctl --user status env-leased` to check its state. Test that the service restarts automatically on login/reboot.",
        "priority": "medium",
        "dependencies": [
          9
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create systemd Service File Template",
            "description": "Define the `env-leased.service` file template. This file will specify how systemd should run the `env-lease` daemon as a user service, including the command to execute and restart policies.",
            "dependencies": [],
            "details": "The template should be a standard `.service` file. It needs a `[Unit]` section with a description, a `[Service]` section specifying `ExecStart` (pointing to the `env-lease daemon run` command), and an `[Install]` section with `WantedBy=default.target`. This template will be embedded into the Go binary.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement `daemon install` Command for Linux",
            "description": "Create the `daemon install` subcommand within a new `daemon_linux.go` file. This command will write the service file template to the correct user directory and enable the service using `systemctl`.",
            "dependencies": [
              "17.1"
            ],
            "details": "Use a build tag `//go:build linux`. Create a new `daemon` command in the `cmd` package. The `install` subcommand should locate the user's config directory (`~/.config/systemd/user/`), write the `env-leased.service` file from the template, and then execute `systemctl --user enable --now env-leased.service` using the `os/exec` package. Handle potential errors.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement `daemon uninstall` Command for Linux",
            "description": "Create the `daemon uninstall` subcommand. This command will stop and disable the systemd service and then remove the service file from the user's configuration directory.",
            "dependencies": [
              "17.2"
            ],
            "details": "In `daemon_linux.go`, add the `uninstall` subcommand. It should first execute `systemctl --user disable --now env-leased.service` to stop and disable the service. After the command succeeds, it should remove the `env-leased.service` file from `~/.config/systemd/user/`. Provide clear feedback to the user on success or failure.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 18,
        "title": "Build and Release Automation",
        "description": "Configure GoReleaser to automate the building of binaries for multiple platforms, and set up a Homebrew tap for easy distribution on macOS.",
        "details": "Create a `.goreleaser.yml` file. Configure it to build binaries for macOS (amd64, arm64) and Linux (amd64, arm64). Set up the `brews` section to publish a formula to a new GitHub repository that will serve as the Homebrew tap (e.g., `github.com/user/homebrew-tap`). The formula should include the service definitions.",
        "testStrategy": "Run `goreleaser release --snapshot --clean` locally to test the build process. For the Homebrew tap, a full release needs to be tagged and pushed to GitHub, followed by a manual `brew install user/tap/env-lease` to verify the installation process works correctly.",
        "priority": "low",
        "dependencies": [
          11,
          12,
          13,
          16,
          17
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Configure GoReleaser for Multi-Platform Binary Builds",
            "description": "Create the initial `.goreleaser.yml` file and configure the `builds`, `archives`, and `checksum` sections to compile binaries for macOS and Linux on both amd64 and arm64 architectures.",
            "dependencies": [],
            "details": "In the project root, create a `.goreleaser.yml` file. Define two build configurations under the `builds` section, one for `cmd/env-lease` and one for `cmd/env-leased`. For each build, set the `goos` to `[linux, darwin]` and `goarch` to `[amd64, arm64]`. Configure the `archives` section to create `.tar.gz` packages and the `checksum` section to generate a `checksums.txt` file for the release artifacts.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Set Up Dedicated Homebrew Tap GitHub Repository",
            "description": "Create a new public GitHub repository that will serve as the Homebrew tap. This repository will store the formula published by GoReleaser.",
            "dependencies": [],
            "details": "Create a new public repository on GitHub with a name following the convention `homebrew-<tap-name>`, for example, `homebrew-env-lease`. Initialize it with a README.md file. Ensure that the Personal Access Token (PAT) used in the CI/CD environment has write permissions to this new repository.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Integrate Homebrew Tap Publishing with launchd Service",
            "description": "Configure the `brews` section in `.goreleaser.yml` to publish the formula to the newly created Homebrew tap repository, including the necessary `launchd` service definition for the daemon.",
            "dependencies": [
              "18.1",
              "18.2"
            ],
            "details": "Add a `brews` section to the `.goreleaser.yml` file. Configure the `tap` to point to the repository created in subtask 18.2. Define the formula details such as `homepage` and `description`. Add a `service` block to automatically generate a `launchd` plist file for the `env-leased` binary, enabling it to be managed by `brew services` on macOS.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 19,
        "title": "Create Comprehensive User Documentation",
        "description": "Develop comprehensive user documentation that includes usage examples for 1Password with both environment variable and file-based leases, and a detailed security section explaining the IPC model and HMAC token protection.",
        "details": "Create a new `/docs` directory in the project repository. The documentation should be written in Markdown. The main document (e.g., `README.md` or `docs/usage.md`) should cover:\n1. **Getting Started:** A quick-start guide covering installation via Homebrew (from the automated release process) and the basic workflow: `env-lease daemon install`, `env-lease grant`, `env-lease status`.\n2. **Configuration:** Detailed explanation of the `env-lease.toml` file structure.\n3. **1Password Examples:** Provide two clear, copy-pasteable examples for the 1Password provider. The first should demonstrate leasing a secret to an environment variable. The second should show how to lease a secret to a file (e.g., for use with `direnv`), highlighting the safety of atomic file writes.\n4. **Security Model:** A dedicated 'Security' section that explains the client-daemon architecture using a Unix Domain Socket. It must detail the HMAC-SHA256 authentication mechanism, explaining that it protects against other local, non-privileged processes impersonating the CLI. Crucially, it must also state the limitations: it does not protect against a root user or sophisticated attacks that can inspect process memory or environment variables to steal the token.\n5. **Command Reference:** A brief reference for all user-facing commands, including `grant`, `revoke`, `status`, and `daemon install/uninstall`.",
        "testStrategy": "The documentation will be verified through a multi-step review process. First, a peer developer will review all technical descriptions and code examples for accuracy by running them on both macOS and Linux test environments. Second, the entire document will be proofread for clarity, grammar, and conciseness. Finally, all links within the documentation must be checked to ensure they are not broken.",
        "status": "done",
        "dependencies": [
          4,
          5,
          12,
          13,
          16,
          17,
          18
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Documentation Structure and 'Getting Started' Guide",
            "description": "Initialize the documentation directory and write the initial 'Getting Started' section. This section will guide a new user through installation via Homebrew and the basic command workflow to get the daemon running and grant a first lease.",
            "dependencies": [],
            "details": "Create a `/docs` directory in the project root. Inside, create a new `USAGE.md` file. Write the 'Getting Started' section covering: 1. Installation instructions using Homebrew. 2. The primary workflow steps: running `env-lease daemon install`, creating a minimal `env-lease.toml`, running `env-lease grant`, and verifying the lease with `env-lease status`.",
            "status": "done",
            "testStrategy": "A team member follows the 'Getting Started' guide on a clean macOS machine to ensure the steps are accurate, easy to follow, and lead to a successful outcome without errors."
          },
          {
            "id": 2,
            "title": "Document Configuration File Structure and Command Reference",
            "description": "Add two new sections to the documentation: one detailing the `env-lease.toml` configuration file structure with all possible options, and another providing a reference for all user-facing CLI commands.",
            "dependencies": [
              "19.1"
            ],
            "details": "In `docs/USAGE.md`, add a 'Configuration' section. Explain the purpose of the file and detail each key in the `[leases.<name>]` table (e.g., `provider`, `source`, `destination`, `type`, `duration`). Provide a complete, commented example `env-lease.toml`. Then, add a 'Command Reference' section that lists and briefly describes `grant`, `revoke`, `status`, and the `daemon install/uninstall` subcommands.",
            "status": "done",
            "testStrategy": "Review the documented configuration options against the actual implementation in the Go structs (from Task 2). Verify that the command descriptions and flags match the CLI's `--help` output for accuracy."
          },
          {
            "id": 3,
            "title": "Write 1Password Provider Usage Examples",
            "description": "Create a dedicated section with practical, copy-pasteable examples for using the 1Password provider to lease secrets to both environment variables and files, demonstrating the two primary use cases.",
            "dependencies": [
              "19.1",
              "19.2"
            ],
            "details": "In `docs/USAGE.md`, add a '1Password Examples' section. Example 1: Show the `env-lease.toml` configuration for leasing a 1Password secret to an environment variable. Include the `env-lease grant` command and how to verify it (e.g., `printenv SECRET_KEY`). Example 2: Show the configuration for leasing a secret to a file. Emphasize that this uses atomic writes for safety and is useful with tools like `direnv`. Provide the full configuration and commands for this scenario.",
            "status": "done",
            "testStrategy": "Execute both examples in a real terminal session with the 1Password CLI configured. Verify that the secrets are correctly leased to the environment and the file, respectively, and that they can be successfully revoked."
          },
          {
            "id": 4,
            "title": "Draft the Security Model Section",
            "description": "Write a detailed 'Security' section explaining the inter-process communication (IPC) model, the HMAC token authentication mechanism, and its security guarantees and limitations.",
            "dependencies": [
              "19.1"
            ],
            "details": "In `docs/USAGE.md`, create a 'Security' section. Explain the client-daemon architecture using a Unix Domain Socket for local IPC. Detail the HMAC-SHA256 authentication process: the daemon generates a token, the client reads it, and all subsequent requests are signed. Explicitly state that this prevents other local, non-privileged users from impersonating the client. Crucially, add a 'Limitations' subsection that clarifies it does *not* protect against a root user or attacks that can read process memory/environment to steal the token.",
            "status": "done",
            "testStrategy": "Peer review by a developer familiar with the IPC implementation to ensure the technical explanation of the HMAC mechanism, its purpose, and its limitations is accurate and clearly communicated to the user."
          },
          {
            "id": 5,
            "title": "Finalize, Proofread, and Link Documentation",
            "description": "Conduct a comprehensive review of the entire documentation for clarity, consistency, and technical accuracy. Proofread for grammatical errors and link the new documentation from the main project README.",
            "dependencies": [
              "19.1",
              "19.2",
              "19.3",
              "19.4"
            ],
            "details": "Read through the entire `docs/USAGE.md` file from start to finish. Check for consistent terminology and formatting. Manually verify all code blocks and command examples are correct. Proofread for spelling and grammar mistakes. Finally, edit the root `README.md` file to add a prominent 'Documentation' or 'Usage' section that links directly to `docs/USAGE.md`.",
            "status": "done",
            "testStrategy": "Have a team member who was not involved in writing the documentation read it from the perspective of a new user. They should check if it's easy to understand, if all examples work as described, and if all internal and external links are correct."
          }
        ]
      },
      {
        "id": 20,
        "title": "Create Quick-Start README.md Guide",
        "description": "Develop a `README.md` file to serve as a quick-start guide for new users. It will cover essential installation, configuration, and usage steps to get started with the tool quickly.",
        "details": "The `README.md` file should be placed in the project root. It needs to be concise and focused on the most common user journey. The content should include:\n1. **Introduction:** A brief, one-paragraph summary of what `env-lease` is and the problem it solves.\n2. **Installation:** Provide the specific command for installing via the Homebrew tap, e.g., `brew install user/tap/env-lease`.\n3. **Setup:** A step-by-step guide on how to initialize the daemon for both macOS (`env-lease daemon install`) and Linux, explaining that this is a one-time setup.\n4. **Configuration:** Show a minimal `env-lease.toml` example focused solely on using the 1Password provider. The example should clearly illustrate the `op://` URI format for sourcing secrets.\n5. **Core Commands:** Demonstrate the primary workflow with simple, copy-pasteable examples for `env-lease grant`, `env-lease status`, and `env-lease revoke`.\n6. **Next Steps:** Conclude with a link to the full user documentation (from Task 19) for users seeking advanced configuration or more detailed explanations.",
        "testStrategy": "Verification will be performed by following the `README.md` guide from the perspective of a new user on a clean system. The tester must execute every command exactly as written to ensure accuracy. Key verification steps include:\n1. **Installation Check:** Run the `brew install` command on a macOS machine and confirm that the `env-lease` binary is installed correctly.\n2. **Daemon Check:** Follow the `env-lease daemon install` instructions for both macOS and Linux, and verify using `launchctl` and `systemctl` respectively that the service is running.\n3. **Functionality Check:** Use the provided example `env-lease.toml` to run `grant`, `status`, and `revoke`. Confirm that each command behaves as described in the guide.\n4. **Peer Review:** Another developer will review the document for technical accuracy, clarity, and grammatical correctness. The link to the full documentation must also be verified.",
        "status": "done",
        "dependencies": [
          4,
          12,
          13,
          16,
          17,
          18,
          19
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Draft README Introduction and Installation Sections",
            "description": "Create the initial `README.md` file in the project root. This subtask involves writing the introductory paragraph that explains the purpose of `env-lease` and adding the 'Installation' section with the specific Homebrew command.",
            "dependencies": [],
            "details": "In the project root, create a new file named `README.md`. Add a main heading for the project. Write a concise, one-paragraph summary explaining what `env-lease` is and the problem it solves (e.g., managing short-lived secrets). Then, add a second-level heading for 'Installation' and provide the exact, copy-pasteable Homebrew command: `brew install user/tap/env-lease` within a Markdown code block.",
            "status": "done",
            "testStrategy": "Review the generated Markdown file. Verify that the introduction is clear and accurately describes the project's purpose. Check that the Homebrew command is syntactically correct and matches the project's tap."
          },
          {
            "id": 2,
            "title": "Add Daemon Setup and 1Password Configuration Sections",
            "description": "Extend the `README.md` by adding the 'Setup' and 'Configuration' sections. This will guide the user through the one-time daemon installation and provide a minimal, working configuration example for the 1Password provider.",
            "dependencies": [
              "20.1"
            ],
            "details": "Append a 'Setup' section to the `README.md`. Explain that this is a one-time step and provide the command `env-lease daemon install`, noting its support for both macOS and Linux. Next, add a 'Configuration' section. Explain that the configuration lives at `~/.config/env-lease/env-lease.toml`. Provide a minimal TOML code block example focused solely on a 1Password lease, clearly showing the `provider`, `source` (using `op://` URI format), and `duration` fields.",
            "status": "done",
            "testStrategy": "Verify that the `env-lease daemon install` command is correct. Check the `env-lease.toml` example for valid TOML syntax and ensure it clearly demonstrates the required configuration for a 1Password lease. The example should be easy for a new user to adapt."
          },
          {
            "id": 3,
            "title": "Document Core Commands and Add Link to Full Documentation",
            "description": "Complete the quick-start guide by adding the 'Core Commands' section, demonstrating the primary user workflow (`grant`, `status`, `revoke`). Conclude the README by adding a 'Next Steps' section that links to the comprehensive user documentation.",
            "dependencies": [
              "20.2"
            ],
            "details": "Add a 'Core Commands' or 'Usage' section to the `README.md`. Provide simple, copy-pasteable examples for the main workflow: 1. `env-lease grant <lease-name> -- <command-to-run>` to grant a lease. 2. `env-lease status` to check active leases. 3. `env-lease revoke <lease-name>` to revoke a lease. Finally, add a 'Next Steps' section at the end of the file. Include a hyperlink to the full user documentation (from Task 19), directing users there for advanced topics.",
            "status": "done",
            "testStrategy": "From a user's perspective, read through the 'Core Commands' section and manually execute each example command to ensure they are correct and the descriptions are clear. Verify that the link in the 'Next Steps' section correctly points to the location of the comprehensive documentation."
          }
        ]
      },
      {
        "id": 21,
        "title": "Add Go Package Documentation Headers",
        "description": "Implement standard Go documentation comments (godoc) for all public packages, functions, and types to improve code maintainability and enable auto-generated documentation.",
        "details": "Review every package in the project and add Go documentation comments where missing. The documentation should follow the official `godoc` conventions. Each public package should have a package-level comment (e.g., in a `doc.go` file) explaining its role. All exported functions, methods, types, and constants must have a clear, concise comment describing their purpose, parameters, and return values. For example, a function comment should start with the function's name: `// MyFunction does X and Y.`. Pay special attention to packages related to core logic such as IPC, configuration, daemon management, and the specific CLI commands for system service integration.",
        "testStrategy": "Verification will be done through a combination of automated checks and manual review. First, run a linter configured to report missing comments on public APIs. Second, start a local godoc server using `godoc -http=:6060` and browse to the project's documentation. A reviewer must check that all public packages, functions, and types are documented, and that the documentation is clear, accurate, and well-formatted. The review should confirm that package overviews are present and provide sufficient context.",
        "status": "done",
        "dependencies": [
          16,
          17
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 22,
        "title": "Implement Warning for Leases Exceeding 12 Hours",
        "description": "Modify the `env-lease grant` command to display a warning message to the user when they request a lease with a duration longer than 12 hours, promoting security best practices.",
        "details": "The `grant` command logic needs to be updated. After parsing the lease duration provided by the user (e.g., via a `--duration` flag), a check must be added to compare it against a 12-hour threshold (12 * 60 * 60 seconds). If the requested duration is greater than 12 hours, a warning message should be printed to standard error (stderr). The message should be informative, for example: \"Warning: Leases longer than 12 hours are discouraged for security reasons. Please consider a shorter duration.\" The command should then proceed with granting the lease as usual; this is a non-blocking warning, not an error.",
        "testStrategy": "Verification will be done via manual CLI testing and automated unit tests.\n1. **Manual Test Cases:**\n   - Run `env-lease grant --duration 8h ...` and confirm no warning is displayed.\n   - Run `env-lease grant --duration 12h ...` and confirm no warning is displayed.\n   - Run `env-lease grant --duration '12h1m' ...` and confirm the warning message is printed to stderr and the lease is still created successfully.\n   - Run `env-lease grant --duration 2d ...` and confirm the warning is printed to stderr.\n2. **Automated Tests:**\n   - Add a new unit test for the grant command's execution logic. The test should capture the output to stderr and assert that the warning message is present for durations greater than 12 hours and absent for durations less than or equal to 12 hours.",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 23,
        "title": "Implement `--override` Logic for `grant` Command",
        "description": "Modify the `grant` command's server-side logic to fail by default if an environment variable already exists, preventing accidental overwrites. The operation should only succeed if the `--override` flag is explicitly provided.",
        "details": "The current implementation of the `grant` command overwrites existing variables in the target `.env` file by default. This task corrects this behavior. The logic should be implemented in the daemon's `handleGrant` function. Before writing any variables, the handler must parse the target `.env` file to check for existing keys. If a variable from the grant request already exists in the file and the `override` flag in the `GrantRequest` is `false`, the entire operation must be aborted, and an error must be returned to the client. The error message should clearly state which variable caused the conflict and instruct the user to use the `--override` flag. If the flag is `true`, the existing variable should be overwritten as intended.",
        "testStrategy": "Create a multi-part test suite. 1. **Unit Test:** In the daemon's grant handler test, create a mock `.env` file with a pre-existing variable (e.g., `API_KEY=old_value`). Send a `GrantRequest` for the same variable without the override flag and assert that an error is returned and the file remains unchanged. Then, send the same request with the override flag set to `true` and assert that the operation succeeds and the file is updated. 2. **Integration Test:** Execute the `env-lease grant` CLI command against a test `.env` file containing a conflicting variable. Verify that the command fails with a non-zero exit code and an informative error message. Then, execute `env-lease grant --override` and verify that the command succeeds and the variable in the `.env` file is correctly updated.",
        "status": "done",
        "dependencies": [
          9,
          11
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 24,
        "title": "Improve CLI Error Handling for Daemon Connection Failure",
        "description": "Refine the CLI's error handling to provide a clear, user-friendly message when it fails to connect to the daemon, instead of showing a generic error and stack trace.",
        "details": "Currently, when the CLI attempts to communicate with a non-running daemon, it exits with a generic connection error and a stack trace. This task involves modifying the CLI client's IPC connection logic to specifically catch socket connection errors. When such an error is detected, the CLI should print a formatted, helpful message to stderr, such as 'Error: Could not connect to the env-lease daemon at [socket_path]. Is the daemon running? Try starting it with `env-lease daemon start`.' The application should then exit with a non-zero status code without displaying a stack trace. The socket path should be dynamically retrieved from the application's configuration.",
        "testStrategy": "To test this, first ensure the `env-leased` daemon is not running. Then, execute any CLI command that requires daemon communication, like `env-lease status` or `env-lease grant`. Verify that the command fails and prints a user-friendly error message to stderr that includes the socket path and suggests the daemon may not be running. Crucially, confirm that no Go stack trace is printed. Finally, start the daemon and run the same command again to ensure it now connects and executes successfully, confirming the error handling is specific to the connection failure scenario.",
        "status": "done",
        "dependencies": [
          9
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 25,
        "title": "Implement Minimal Daemon Event Logging",
        "description": "Introduce basic logging to the daemon for key events such as successful grants, manual revocations, and automatic lease expirations to improve operational visibility.",
        "details": "Integrate the standard `log` package into the daemon's main process. Logging should be directed to standard output to be easily captured by service managers like systemd. Add single-line log messages at the following key locations:\n1. In the `handleGrant` function, after all secrets have been successfully fetched and written, log a message like `INFO: Leases granted for project [project_config_path]`.\n2. In the `handleRevoke` function, after all leases for a project have been successfully revoked, log a message like `INFO: Leases manually revoked for project [project_config_path]`.\n3. In the core timer loop that manages lease expiration, after a lease is successfully revoked due to its TTL expiring, log a message like `INFO: Lease [lease_identifier] expired and was revoked.`",
        "testStrategy": "Testing will be performed via integration tests that monitor the daemon's standard output. Start the daemon in a test process and capture its stdout/stderr streams. \n1. **Grant Logging:** Execute the `env-lease grant` command. Assert that the daemon's output contains the expected 'Leases granted' log message.\n2. **Revoke Logging:** After granting a lease, execute the `env-lease revoke` command. Assert that the daemon's output contains the 'Leases manually revoked' log message.\n3. **Expiration Logging:** Grant a lease with a very short TTL (e.g., 2 seconds). Wait for 3 seconds and then assert that the daemon's output contains the 'Lease expired and was revoked' log message.",
        "status": "done",
        "dependencies": [
          9,
          14,
          23
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 26,
        "title": "Bugfix: Persist Daemon State Immediately After Modification",
        "description": "Fixes a critical bug where daemon state was only saved on graceful shutdown. This change ensures the state is written to disk immediately after any lease is granted, manually revoked, or automatically expired, preventing data loss on unexpected termination.",
        "details": "The current implementation only calls `SaveState()` during a graceful shutdown sequence. This creates a race condition where a `kill -9` or system crash can cause recently granted leases to be lost. To fix this, the `SaveState()` method, defined in Task 7, must be invoked immediately after any operation that modifies the daemon's lease map. Specifically, a call to `this.SaveState()` should be added in the following locations:\n1. In the `handleGrant` function (from Task 9), after a new lease has been successfully added to the state map.\n2. In the `handleRevoke` function (from Task 9), after a lease has been successfully removed from the state map.\n3. In the daemon's core timer loop (from Task 8), immediately after the logic that removes an expired lease from the state map.\nAny error returned by `SaveState()` should be logged as a warning, but should not cause the primary operation (grant/revoke) to fail.",
        "testStrategy": "Testing must verify that state is persisted correctly after each type of modification and survives an unclean shutdown.\n1. **Integration Test (Grant):** Start the daemon. Execute `env-lease grant`. Use `kill -9` to terminate the daemon process immediately. Manually inspect the `~/.config/env-lease/state.json` file to confirm the new lease is present. Restart the daemon and use `env-lease status` to verify the lease is active.\n2. **Integration Test (Manual Revoke):** Start the daemon with an existing lease. Execute `env-lease revoke`. Use `kill -9` to terminate the daemon. Inspect `state.json` to confirm the lease has been removed.\n3. **Unit Test (Timed Revocation):** In a unit test for the core daemon loop, use a mock clock and a mock filesystem. Grant a lease with a short duration (e.g., 1 second). Advance the mock clock to trigger the expiration. Verify that the mock `SaveState` function is called exactly once after the lease is removed from the internal state map.",
        "status": "done",
        "dependencies": [
          7,
          8,
          9
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 27,
        "title": "Bugfix: Refine `grant` Override Logic to Ignore Empty Variables",
        "description": "Modify the `grant` command's override check to permit overwriting environment variables that exist in the destination file but have an empty value, without requiring the `--override` flag. This prevents failures when re-granting expired or cleared leases.",
        "details": "The current override logic in the daemon's `handleGrant` function, introduced in Task #23, blocks any attempt to write a variable that already exists without the `--override` flag. This needs to be refined. The check should be updated to only trigger the failure if the existing variable has a non-empty value. Specifically, when parsing the destination file, if a key exists but its value is an empty string (e.g., `API_KEY=`), it should be considered safe to overwrite. The operation should only be aborted if the key exists, its value is non-empty, and the `override` flag is false.",
        "testStrategy": "Create a test suite targeting the daemon's `handleGrant` function. Prepare a target `.env` file containing `EXISTING_VAR=old_value` and `EMPTY_VAR=`. 1. Send a GrantRequest for `EMPTY_VAR` without the override flag; assert that the operation succeeds and the file is updated. 2. Send a GrantRequest for `EXISTING_VAR` without the override flag; assert that the operation fails with an error. 3. Send a GrantRequest for `EXISTING_VAR` with the override flag; assert that the operation succeeds and the file is updated. 4. Send a GrantRequest for a completely new variable; assert it succeeds.",
        "status": "done",
        "dependencies": [
          11,
          23
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 28,
        "title": "Bugfix: Refine `grant` Override Logic to Ignore Empty Variables",
        "description": "Modify the `grant` command's override check to permit overwriting environment variables that exist in the destination file but have an empty value, without requiring the `--override` flag. This prevents failures when re-granting expired or cleared leases.",
        "details": "The current override logic in the daemon's `handleGrant` function, introduced in Task #23, blocks any attempt to write a variable that already exists without the `--override` flag. This needs to be refined. The check should be updated to only trigger the failure if the existing variable has a non-empty value. Specifically, when parsing the destination file, if a key exists but its value is an empty string (e.g., `API_KEY=`), it should be considered safe to overwrite. The operation should only be aborted with an error if a grant is attempted for an existing key that has a non-empty value and the `--override` flag is false.",
        "testStrategy": "Create a comprehensive test suite targeting the daemon's `handleGrant` function. Prepare a target `.env` file containing `EXISTING_VAR=old_value` and `EMPTY_VAR=`. 1. Send a GrantRequest for `EMPTY_VAR` with a new value but without the override flag; assert that the operation succeeds and the file is updated. 2. Send a GrantRequest for `EXISTING_VAR` without the override flag; assert that the operation fails and the file remains unchanged. 3. Send a GrantRequest for `EXISTING_VAR` with the override flag; assert that the operation succeeds and the file is updated. 4. Send a GrantRequest for a new variable not present in the file; assert it is added successfully.",
        "status": "done",
        "dependencies": [
          11,
          23
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 29,
        "title": "Bugfix: Make `grant` Command Idempotent by Ignoring Same-Value Overrides",
        "description": "Modify the `grant` command's override check to permit overwriting a variable if the exact line to be written already exists in the destination file. This makes the command idempotent and prevents unnecessary failures when re-running.",
        "status": "done",
        "dependencies": [
          11,
          27
        ],
        "priority": "medium",
        "details": "The current override protection in the daemon's `handleGrant` function is too strict. This change will make the check smarter by comparing the formatted output rather than parsing existing values.\n\nFor `env` lease types:\n1. The daemon must first format the new secret into the exact line that would be written to the file (e.g., `export API_KEY=\"secret123\"`).\n2. It will then read the destination file line by line.\n3. If any existing line is a byte-for-byte match for the newly formatted line, the write operation is skipped and the grant is considered a success. This avoids complex parsing of keys and values.\n\nFor `file` lease types:\n1. The daemon will read the entire content of the target file.\n2. If the existing content is byte-for-byte identical to the new secret value, the write is skipped and the grant succeeds.\n\nIf no match is found and the variable/file already exists with different content, the existing override logic (fail unless `--override` is specified) should still apply.",
        "testStrategy": "Create integration tests that target the daemon's grant handling logic.\n1. **Env Lease Idempotency:** Prepare a `.env` file containing the exact line `API_KEY=secret123`. Send a GrantRequest for `API_KEY` with the value `secret123` without the override flag. Assert the command succeeds because an identical line is found.\n2. **Env Lease Conflict:** Using the same file, send a GrantRequest for `API_KEY` with a different value (`secret456`) without the override flag. Assert the command fails with an override error because no identical line is found and the key already exists.\n3. **File Lease Idempotency:** Prepare a file `secret.txt` containing `secret123`. Send a GrantRequest for a `file` lease targeting `secret.txt` with the same value. Assert the command succeeds based on a full content match.\n4. **File Lease Conflict:** Using the same file, send a GrantRequest for a `file` lease with a different value. Assert the command fails with an override error."
      },
      {
        "id": 30,
        "title": "Bugfix: Preserve Unrelated Content in `.env` Files During Grant",
        "description": "Fix a bug where the `grant` command for `env`-type leases overwrites the entire destination file. The logic must be updated to parse the file, modify only the relevant lines, and preserve all other content.",
        "details": "The current implementation for handling `env`-type leases writes the secret directly to the destination file, truncating any existing content. This needs to be changed to a read-modify-write approach. The daemon's `handleGrant` function, when processing a lease for a `.env` file, must first read the entire file into memory. It should then parse the file line-by-line, identifying existing key-value pairs, comments, and empty lines. For each secret to be granted, the logic will check if the key already exists. If it does, the existing line will be replaced with the new `KEY=VALUE` pair. If it does not exist, a new line will be appended to the file content. All other lines, including comments and blank lines, must be preserved in their original order. Finally, the newly constructed content will be written back to the file, completely replacing the old content in an atomic operation (e.g., write to a temp file and rename).",
        "testStrategy": "Create a comprehensive integration test suite. Start with a predefined `.env` file containing:\n```\n# API Keys\nEXISTING_KEY=old_value\n\n# This should be preserved\nUNRELATED_KEY=abc\n```\n1. **Update Existing Variable:** Run `grant` for `EXISTING_KEY` with a new value. Verify that only the value for `EXISTING_KEY` is updated and all other lines (comments, blank lines, `UNRELATED_KEY`) are preserved.\n2. **Append New Variable:** Run `grant` for a `NEW_KEY`. Verify that `NEW_KEY=new_value` is appended to the file and the original content is untouched.\n3. **Target Non-Existent File:** Run `grant` targeting a file that does not exist. Verify the file is created with the correct content.\n4. **Multiple Operations:** Run a single `grant` command that updates `EXISTING_KEY` and adds `NEW_KEY`. Verify both operations are successful and the file integrity is maintained.",
        "status": "done",
        "dependencies": [
          11,
          27,
          29
        ],
        "priority": "medium"
      },
      {
        "id": 31,
        "title": "Implement `file_mode` Option for File-Type Leases",
        "description": "Add a `file_mode` option to the `env-lease.toml` configuration for `file`-type leases, allowing users to specify custom file permissions for the created secret files.",
        "details": "1. **Configuration Parsing:** Modify the Go struct representing a lease in the configuration parser (related to Task 2). Add a new optional field, such as `FileMode string`, to capture the `file_mode` setting from the TOML file. 2. **Daemon Logic:** Update the daemon's lease granting logic. When processing a `file`-type lease, check if the `FileMode` field is set. If it is, parse the string (e.g., \"0600\") into an `os.FileMode` (octal integer). Implement validation to ensure the provided string is a valid file mode. 3. **Default Value:** If the `FileMode` field is empty or not present in the configuration, the daemon must use a default file mode of `0644`. 4. **File Writing:** Pass the determined file mode (either the user-specified one or the default) to the `AtomicWriteFile` utility (from Task 6) when writing the secret to the destination file.",
        "testStrategy": "1. **Unit Tests (Configuration):** Add unit tests for the TOML parser. Create test cases with `file`-type leases that: a) include a valid `file_mode` like \"0600\", b) omit the `file_mode` key, and c) include an invalid `file_mode` like \"not_a_mode\". Verify the parser correctly populates the struct or returns an error. 2. **Unit Tests (Daemon):** Write unit tests for the daemon's file-lease handler. Using a mock filesystem, verify that the `AtomicWriteFile` utility is called with the correct `os.FileMode`: `0600` when specified, and `0644` when omitted. 3. **Integration Test:** Create an end-to-end test. Define an `env-lease.toml` with a `file`-type lease and `file_mode = \"0600\"`. Execute the `env-lease grant` command. After execution, use `os.Stat` to inspect the created file on the filesystem and assert that its permissions are exactly `0600`. Run a second integration test without the `file_mode` key and assert the permissions are `0644`.",
        "status": "done",
        "dependencies": [
          2,
          6,
          11
        ],
        "priority": "medium"
      },
      {
        "id": 32,
        "title": "Combine CLI and Daemon into a Single Binary",
        "description": "Analyze the feasibility and benefits of merging the `env-lease` CLI and `env-leased` daemon into a single executable. Refactor the Cobra command structure to support both client and daemon subcommands within one binary.",
        "details": "The CLI and daemon currently exist as two separate binaries but share a common Cobra command structure, suggesting an opportunity for consolidation. This task involves refactoring the project to produce a single `env-lease` binary. The daemon's functionality will be moved under a new subcommand, for example, `env-lease daemon start`. All existing CLI commands (`grant`, `revoke`, `status`, etc.) will remain as top-level commands of the unified binary. This will involve merging the `main.go` files, reorganizing the Cobra command definitions, and updating the build process to produce only one artifact. The goal is to simplify distribution, reduce build complexity, and eliminate code duplication.",
        "testStrategy": "Verification will be performed end-to-end. First, update the build scripts and confirm that only a single `env-lease` binary is generated. Second, start the daemon in the background using the new subcommand (`env-lease daemon start`) and verify its logs (Task 25) indicate a successful startup. Third, execute all existing CLI commands (`grant`, `status`, `revoke`) against the running daemon and confirm they function identically to the previous two-binary setup. Finally, stop the daemon and run a command like `env-lease status` to ensure the user-friendly connection error message (from Task 24) is still displayed correctly.",
        "status": "done",
        "dependencies": [
          9,
          24
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 33,
        "title": "Update Systemd Service Template for Unified Binary",
        "description": "Modify the systemd service template and the `daemon install` command to support the new single-binary architecture, ensuring the service correctly starts the daemon using the `daemon start` subcommand.",
        "details": "Following the consolidation of the CLI and daemon into a single executable in Task 32, the systemd service integration from Task 17 is now broken. This task involves updating the service file template to execute the daemon via its new subcommand. The `ExecStart` directive in the service template must be changed from pointing to the old `env-leased` binary to invoking `env-lease daemon start`. The `env-lease daemon install` command logic needs to be updated to generate this new configuration. The path to the executable in `ExecStart` should be dynamically determined using a function like `os.Executable()` to ensure it points to the correct location of the running `env-lease` binary. The service file should also be renamed from `env-leased.service` to `env-lease.service` for consistency.",
        "testStrategy": "Testing must be performed on a Linux system with systemd. First, build the unified binary from Task 32. Then, run the updated `env-lease daemon install` command. Verify that a file named `env-lease.service` is created in `~/.config/systemd/user/`. Inspect the contents of this file to confirm the `ExecStart` line correctly points to the absolute path of the binary and uses the `daemon start` subcommand. Use `systemctl --user daemon-reload`, then `systemctl --user start env-lease.service`. Check the service's status with `systemctl --user status env-lease.service` to ensure it is active and running. Finally, check the daemon's logs via `journalctl --user -u env-lease.service` to confirm a successful startup message is present.",
        "status": "done",
        "dependencies": [
          17,
          32,
          25
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 34,
        "title": "Add HashiCorp Vault Provider",
        "description": "Implement a new secret provider for HashiCorp Vault. The implementation should follow the existing pattern of the 1Password provider, using the Vault CLI ('vault') to fetch secrets. The provider should have a `Fetch` method that takes a source URI (e.g., 'secret/data/my-secret key') and returns the secret value. Error handling should be similar to the 1Password provider, with custom error types for Vault-specific errors.",
        "details": "",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 35,
        "title": "Add AWS Secrets Manager Provider",
        "description": "Implement a new secret provider for AWS Secrets Manager. The implementation should follow the existing pattern of the 1Password provider, using the AWS CLI ('aws') to fetch secrets. The provider should have a `Fetch` method that takes a source URI (the secret ARN) and returns the secret value. Error handling should be similar to the 1Password provider, with custom error types for AWS-specific errors.",
        "details": "",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 36,
        "title": "Implement `--continue-on-error` Flag for `grant` Command",
        "description": "Modify the `grant` command to support a `--continue-on-error` flag. When enabled, the command will attempt to fetch all requested secrets, aggregate any errors encountered, and report them at the end, rather than exiting on the first failure.",
        "details": "This task involves modifying both the CLI and the daemon. On the CLI side, a new `--continue-on-error` boolean flag will be added to the `grant` command. The IPC `GrantRequest` struct must be updated to include a corresponding boolean field to transmit the flag's state to the daemon. On the daemon side, the `handleGrant` function will be updated. If the `ContinueOnError` field is true, the secret fetching loop should not exit on the first error. Instead, it should collect each error encountered into a slice. After iterating through all requested leases, if the error slice is not empty, the daemon should return a single, aggregated error message to the client detailing all the failures. Successfully fetched secrets should still be written to the environment file.",
        "testStrategy": "Testing will be multi-layered. First, create unit tests for the daemon's `handleGrant` function using a mock secret provider. Configure the mock to successfully return some secrets but fail on others. Test two scenarios: 1) With `ContinueOnError` set to false, assert that the handler returns immediately on the first failure. 2) With `ContinueOnError` set to true, assert that the handler processes all secrets, writes the successful ones, and returns a single aggregated error containing details for all failures. Second, add an end-to-end integration test. Configure a project with multiple secrets, run `env-lease grant --continue-on-error`, and verify that the command exits with a non-zero status, reports the specific failures to stderr, and that the successfully fetched secrets are present in the output file.",
        "status": "pending",
        "dependencies": [
          9,
          10,
          23
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 37,
        "title": "Modify `revoke` Command for Project-Scoped Revocation with `--all` Flag",
        "description": "Update the `revoke` command to only revoke leases for the current project by default, based on the `env-lease.toml` configuration. Introduce an `--all` flag to preserve the original global revocation behavior.",
        "details": "The current `revoke` command is too broad, clearing all active leases regardless of their origin. This task refactors it to be project-aware. The default behavior will be to revoke only the leases associated with the current project's `env-lease.toml` file. This includes leases that are currently active for the project but may have been removed from the configuration file since they were last granted. To support the original functionality, a new `--all` flag will be added to perform a global revocation of all active leases. This will require modifying the CLI command to parse the configuration and updating the IPC message and daemon logic to handle both scoped and global revocation requests.",
        "testStrategy": "Testing will be performed through a series of integration tests. \n1. **Default Scoped Revoke:** Create two separate project directories with distinct `env-lease.toml` files. Grant leases for both projects. `cd` into one project directory and run `env-lease revoke`. Use `env-lease status` to verify that only the leases for that specific project have been revoked, while the other project's leases remain active. \n2. **`--all` Flag Revoke:** Set up the same multi-project scenario as above. Run `env-lease revoke --all` from one of the project directories. Use `env-lease status` to verify that all leases from *both* projects have been revoked. \n3. **Stale Lease Revocation:** Grant leases for a project. Then, edit the `env-lease.toml` to remove one of the lease definitions. Run `env-lease revoke` in that project. Verify that all original leases for that project, including the one no longer in the config file, are successfully revoked.",
        "status": "pending",
        "dependencies": [
          12,
          11,
          2
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 38,
        "title": "Add Google Secret Manager Provider",
        "description": "Implement a new secret provider for Google Secret Manager. The implementation should follow the existing pattern of the 1Password provider, using the Google Cloud CLI ('gcloud') to fetch secrets. The provider should have a `Fetch` method that takes a source URI (the secret name and version) and returns the secret value. Error handling should be similar to the 1Password provider, with custom error types for Google Cloud-specific errors.",
        "details": "",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 39,
        "title": "Add Azure Key Vault Provider",
        "description": "Implement a new secret provider for Azure Key Vault. The implementation should follow the existing pattern of the 1Password provider, using the Azure CLI ('az') to fetch secrets. The provider should have a `Fetch` method that takes a source URI (the secret name and vault name) and returns the secret value. Error handling should be similar to the 1Password provider, with custom error types for Azure-specific errors.",
        "details": "",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 40,
        "title": "Add --print Flag to `daemon install` Command",
        "description": "Implement a `--print` flag for the `daemon install` command. This flag will output the generated service configuration file to stdout and prevent the actual installation, facilitating debugging and manual setup.",
        "details": "Modify the `daemon install` Cobra command, which was established as part of the unified binary in Task 32. Add a new persistent boolean flag named `--print`. The command's execution logic should be updated to check if this flag is present. If `--print` is true, the command must generate the appropriate service configuration content (a `.plist` file for macOS, a `.service` file for Linux) as a string. This string should be printed directly to standard output. Concurrently, a warning message, such as 'WARNING: Service configuration printed but not installed.', should be printed to standard error. The command should then exit without attempting to write any files to system directories or execute service management commands (`launchctl`, `systemctl`). If the `--print` flag is not provided, the command should execute its original installation logic without change.",
        "testStrategy": "Testing will involve running the command on both supported platforms and verifying the output streams and system state. 1. On Linux, run `env-lease daemon install --print`. Capture stdout and assert that its content is a valid systemd `.service` file. Capture stderr and assert it contains the warning message. Verify that no file was created in `~/.config/systemd/user/` and `systemctl` was not invoked. 2. On macOS, run `env-lease daemon install --print`. Capture stdout and assert its content is a valid XML `.plist` file. Capture stderr and assert it contains the warning message. Verify no file was created in `~/Library/LaunchAgents/` and `launchctl` was not invoked. 3. On both platforms, run `env-lease daemon install` without the flag to confirm that the original installation behavior is preserved and that nothing is printed to stdout.",
        "status": "pending",
        "dependencies": [
          32
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 41,
        "title": "Refine `grant` Override Logic to Allow Overwriting Empty Variables",
        "description": "Modify the `grant` command's override check to permit overwriting an environment variable if its existing value is empty, without requiring the `--override` flag. This improves usability when re-granting leases for variables that have been cleared.",
        "details": "The current override protection within the daemon's `handleGrant` function is overly strict and incorrectly flags a variable with an empty value as a conflict, contrary to the intent of previous fixes. This task will correct the logic. When the daemon processes a `GrantRequest`, it must parse the target file (e.g., `.env`) and check for existing variables. The check must be refined to differentiate between a variable with a non-empty value and one with an empty value. If a variable exists but its value is an empty string (e.g., `API_KEY=`), the operation should succeed without the `--override` flag, overwriting the line with the new key and secret. The conflict requiring `--override` should only be triggered if the existing variable has a non-empty value (e.g., `API_KEY=\"old_secret\"`).",
        "testStrategy": "Create a comprehensive integration test suite targeting the daemon's grant handling logic. Prepare a target `.env` file with the following contents: `EXISTING_VAR=old_value` and `EMPTY_VAR=`. 1. **Empty Value Overwrite:** Send a GrantRequest for `EMPTY_VAR` with a new value, but without the `--override` flag. Assert that the operation succeeds and the file is correctly updated. 2. **Non-Empty Conflict:** Send a GrantRequest for `EXISTING_VAR` with a new value, without the `--override` flag. Assert that the operation fails with an error indicating the variable already exists. 3. **Override Success:** Send a GrantRequest for `EXISTING_VAR` with a new value and the `--override` flag. Assert the operation succeeds and the file is updated.",
        "status": "done",
        "dependencies": [
          11,
          27
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 42,
        "title": "Implement `direnv` Integration for `grant` Command",
        "description": "Enhance the `grant` and `revoke` commands to automatically execute `direnv allow` when they modify a `.envrc` file. This behavior will be the default if `direnv` is installed. A `--no-direnv` flag will be added to both commands to disable the automatic execution and instead print a suggestion to the user.",
        "status": "pending",
        "dependencies": [
          10,
          23,
          25
        ],
        "priority": "medium",
        "details": "This logic should be implemented within the client-side execution flow for both the `grant` and `revoke` commands. After a successful operation, the CLI should check if the target output file is named `.envrc`. If it is, the client should check if the `direnv` executable is available in the system's `PATH`. If both conditions are met, the CLI should execute `direnv allow` and stream its output to the user. A new boolean flag, `--no-direnv`, should be added to both commands. If this flag is provided, the automatic execution should be skipped, and the message \".envrc modified. Run 'direnv allow' to apply changes.\" should be printed to standard output instead. The command's exit code should not be affected by the `direnv` integration logic.",
        "testStrategy": "Update the integration test suite to cover both `grant` and `revoke` commands. 1. **Default Success Case:** For both commands, configure them to write to `.envrc` with a mock `direnv` in the `PATH`. Execute the command without the flag and assert that the mock `direnv allow` was executed and its output was displayed. 2. **Opt-out Case:** For both commands, run with the `--no-direnv` flag. Assert that the mock `direnv` was *not* executed and that the suggestion message was printed to stdout. 3. **Wrong Filename Case:** Configure the commands to write to a different filename (e.g., `.env`). Verify that `direnv` is not executed and no message is printed. 4. **`direnv` Missing Case:** Configure the commands to write to `.envrc` but ensure `direnv` is not in the `PATH`. Verify that no execution is attempted and no message is printed. 5. **Failed Operation Case:** Simulate a failed `grant` or `revoke` operation. Assert that the `direnv` logic is not triggered.",
        "subtasks": [
          {
            "id": 1,
            "title": "",
            "description": "Modify the `grant` command to check for `.envrc` and `direnv`, and execute `direnv allow` by default.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "",
            "description": "Add a `--no-direnv` flag to the `grant` command to suppress automatic execution and print a suggestion instead.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "",
            "description": "Extend the `direnv` integration logic to the `revoke` command, making it automatically execute `direnv allow`.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "",
            "description": "Add the `--no-direnv` flag to the `revoke` command.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "",
            "description": "Update integration tests for `grant` to cover automatic execution, the `--no-direnv` flag, and edge cases.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "",
            "description": "Update integration tests for `revoke` to cover automatic execution, the `--no-direnv` flag, and edge cases.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 43,
        "title": "Fully Implement Orphaned Lease Cleanup Daemon Logic and Command",
        "description": "Implement the complete daemon logic for detecting, marking, and purging orphaned leases. This includes a periodic background check and updating the `env-lease daemon cleanup` command to trigger the process manually.",
        "details": "This task involves two main components. First, enhance the daemon's core loop to include a periodic background job that runs, for example, every 24 hours. This job will iterate through all active leases managed in the state file (from Task 7). For each lease, it will check for the existence of the source `env-lease.toml` file. If the file does not exist, the lease's entry in the state file should be updated with a new field, such as `orphaned_since`, containing the current timestamp. The job should also check for leases already marked as orphaned. If the current time is more than 30 days past the `orphaned_since` timestamp, the daemon must trigger the internal revocation logic for that lease and remove its entry from the state entirely. Second, the `env-lease daemon cleanup` command must be updated. It will use the IPC client (from Task 10) to send a new `CleanupRequest` to the daemon. A corresponding handler must be added to the daemon's IPC server to receive this request and immediately execute the full orphan detection and purging logic on demand.",
        "testStrategy": "A multi-layered testing approach is required. For unit tests, mock the daemon's state manager and the filesystem. Create a test state with several leases. In one test case, 'delete' the config file for one lease and run the cleanup logic; assert that the lease is now marked as orphaned in the state with a correct timestamp. In another case, create a lease already marked as orphaned 29 days ago, advance a mock clock by two days, run the cleanup logic, and assert that the lease has been completely removed from the state. For integration testing, start a live daemon with a temporary state file, grant a lease, then manually delete the associated `env-lease.toml`. Execute the `env-lease daemon cleanup` command and then use `env-lease status` to verify the lease is now correctly identified as orphaned.",
        "status": "pending",
        "dependencies": [
          7,
          10,
          15
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 44,
        "title": "Implement Lease Expiration Notifications for macOS/Linux",
        "description": "Implement desktop notifications for lease expirations on macOS and Linux. The daemon should detect the operating system and use the appropriate native notification command (`osascript` for macOS, `notify-send` for Linux) to inform the user when a lease has been revoked due to expiration. The notification message should clearly identify which lease has expired.",
        "details": "",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 45,
        "title": "Clear Environment Variable Value in .envrc on Automatic Revocation",
        "description": "Enhance the daemon's automatic lease revocation process to clear the value of the corresponding environment variable in the user's .envrc file, ensuring secrets are removed upon expiration while preserving the variable declaration and any associated comments.",
        "details": "This task modifies the daemon's core revocation logic, triggered when a lease expires. Instead of deleting the line from the .envrc file, the logic will now set the environment variable's value to an empty string. The implementation should be located within the daemon's main loop where expired leases are processed (established in Task 8). The process involves reading the target .envrc file, identifying the specific line for the expired secret's variable, and replacing it. A regular expression should be used to match lines like `export VAR_NAME=...`, capturing the variable name and any trailing comments. The replacement line will be formatted as `export VAR_NAME=\"\"`, preserving the captured comment. This ensures that user-managed comments and the structure of the .envrc file remain intact. The file write operation should be atomic to prevent data corruption in case of an interruption.",
        "testStrategy": "Testing will be divided into unit and integration tests. For unit tests, create a dedicated function that takes a string representing the content of an .envrc file and the name of a variable to clear. Test this function with various inputs: a standard variable assignment, a variable with a trailing comment, a variable with complex quoting, and a file where the variable is not present. Assert that the returned string has the correct line modified to `export VAR_NAME=\"\"` while all other lines and comments are unchanged. For integration testing, start the daemon with a mock clock. Grant a lease with a short TTL (e.g., 1 second). Advance the mock clock to trigger the expiration. Read the content of the test .envrc file from disk and verify that the secret variable's value has been set to an empty string and that any associated comment on that line was preserved.",
        "status": "pending",
        "dependencies": [
          8,
          14
        ],
        "priority": "medium",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-09-21T13:04:46.205Z",
      "updated": "2025-09-27T12:43:00.439Z",
      "description": "Tasks for master context"
    }
  }
}