{
	"meta": {
		"generatedAt": "2025-09-21T13:09:13.669Z",
		"tasksAnalyzed": 18,
		"totalTasks": 18,
		"analysisCount": 18,
		"thresholdScore": 5,
		"projectName": "Taskmaster",
		"usedResearch": true
	},
	"complexityAnalysis": [
		{
			"taskId": 1,
			"taskTitle": "Project Scaffolding and Initialization",
			"complexityScore": 2,
			"recommendedSubtasks": 3,
			"expansionPrompt": "Based on the existing `go.mod`, create the standard Go project directory structure: `/cmd/env-lease`, `/cmd/env-leased`, and `/internal` with subdirectories (`config`, `daemon`, `ipc`, `provider`). Create a new `/cmd/root.go` file to house the main `cobra` root command. Create `main.go` files in each `/cmd` subdirectory to call the root command's `Execute()` function. Finally, remove the non-standard `main.go` from the project root.",
			"reasoning": "The project is partially initialized with `go mod` and a `cobra` dependency, but lacks the standard directory structure. This task is low complexity as it primarily involves creating directories and boilerplate `main` and `cobra` command files, following a well-established pattern. It's foundational but not algorithmically complex."
		},
		{
			"taskId": 2,
			"taskTitle": "Configuration Parsing (`env-lease.toml`)",
			"complexityScore": 3,
			"recommendedSubtasks": 3,
			"expansionPrompt": "In a new package `internal/config`, define Go structs for `Config` and `Lease` to match the `env-lease.toml` structure. Use the `github.com/BurntSushi/toml` library to implement a `Load(path string) (*Config, error)` function. Implement validation for required fields and set default values as described. Create a `config_test.go` file with unit tests for valid, invalid, and edge-case TOML files.",
			"reasoning": "This is a greenfield task involving defining data structures and using a third-party library for parsing. The complexity is slightly above minimal due to the need for validation logic (e.g., required fields, default values) and writing a comprehensive test suite for various configuration file states, which is crucial for robustness."
		},
		{
			"taskId": 3,
			"taskTitle": "Define SecretProvider Interface",
			"complexityScore": 1,
			"recommendedSubtasks": 1,
			"expansionPrompt": "In a new directory `internal/provider`, create a file `provider.go` and define the `SecretProvider` interface with a single method: `Fetch(source string) (string, error)`. Add comments explaining the purpose of the interface and its method.",
			"reasoning": "This task is purely about defining a Go interface, which is a contract for other components. It involves creating one file with a few lines of code and has no implementation logic or tests, making it the lowest possible complexity."
		},
		{
			"taskId": 4,
			"taskTitle": "Implement 1Password CLI Secret Provider",
			"complexityScore": 5,
			"recommendedSubtasks": 3,
			"expansionPrompt": "In the `internal/provider` package, create a `onepassword.go` file. Define a `OnePasswordCLI` struct that implements the `SecretProvider` interface. The `Fetch` method should use `os/exec` to call `op read <source>`. Implement robust error handling for different failure modes, such as the `op` command not being in PATH, non-zero exit codes (e.g., not logged in), and empty output. For testing, create `onepassword_test.go` and use a mocking strategy for `os/exec` to test success and failure scenarios without requiring the actual `op` CLI.",
			"reasoning": "The complexity is moderate because it involves interacting with an external process via `os/exec`. This requires careful handling of command arguments, stdout, stderr, and exit codes. The testing strategy is also more complex as it requires mocking the external command execution, which is a common but non-trivial pattern in Go."
		},
		{
			"taskId": 5,
			"taskTitle": "Implement IPC Framework with HMAC Security",
			"complexityScore": 7,
			"recommendedSubtasks": 4,
			"expansionPrompt": "Create a new package `internal/ipc`. Define message structs for `GrantRequest`, `RevokeRequest`, `StatusRequest` and their corresponding responses. Implement `Sign` and `Verify` functions using HMAC-SHA256 and a shared secret. Create a `Client` struct with a `Send` method that connects to a Unix socket, serializes, signs, and sends a message. Create a `Server` struct with a `Listen` method that accepts connections, reads messages, verifies signatures, and dispatches to handlers. Write integration tests for the client-server communication.",
			"reasoning": "This task is complex because it combines three distinct domains: low-level networking with Unix sockets, data serialization (e.g., JSON), and applied cryptography for security. Getting the message framing, signing, and verification correct is critical, non-trivial, and forms a core, sensitive part of the application's architecture."
		},
		{
			"taskId": 6,
			"taskTitle": "Implement Atomic File Writer Utility",
			"complexityScore": 2,
			"recommendedSubtasks": 2,
			"expansionPrompt": "Create a new package `internal/util`. Inside, create a function `AtomicWriteFile(filename string, data []byte, perm fs.FileMode) error`. Implement it by writing to a temporary file in the same directory using `os.CreateTemp` and then using `os.Rename` to move it to the final destination. Add unit tests to verify correct file content, permissions, and error handling for cases like a non-existent destination directory.",
			"reasoning": "This is a low-complexity task. It implements a well-known, self-contained pattern for atomic writes using only the Go standard library. The logic is straightforward and easy to unit test without complex dependencies."
		},
		{
			"taskId": 7,
			"taskTitle": "Implement Daemon State Management",
			"complexityScore": 3,
			"recommendedSubtasks": 3,
			"expansionPrompt": "In a new `internal/daemon` package, define a `State` struct to hold active lease information (e.g., a map of lease IDs to their metadata and expiration times). Implement `LoadState(path string)` and `SaveState(path string)` methods that use `encoding/json` to read from and write to the given file path. Ensure the directory for the state file is created if it doesn't exist. Write unit tests to cover loading from a non-existent file, a valid file, and a corrupted file.",
			"reasoning": "This task is of low-to-moderate complexity. It involves standard file I/O and JSON serialization, which are well-supported by the standard library. The main considerations are correct user-directory path handling and creating robust tests for edge cases like file corruption or non-existence."
		},
		{
			"taskId": 8,
			"taskTitle": "Implement Daemon Core Logic and Timer Loop",
			"complexityScore": 6,
			"recommendedSubtasks": 4,
			"expansionPrompt": "In `internal/daemon`, create a `Daemon` struct that holds the application state and dependencies. Implement a `Run()` method containing the main loop. Use a `time.Ticker` for periodic checks (e.g., every second). On each tick, iterate through active leases and check if `time.Now()` is after their expiration. If so, trigger the revocation logic. On startup, before the loop begins, perform an initial check to clean up any leases that expired while the daemon was stopped. Use dependency injection for dependencies like the filesystem and clock to facilitate testing.",
			"reasoning": "This is a moderately complex task as it forms the core logic of the daemon. It involves managing a stateful, long-running process with time-based triggers. Concurrency (running the loop) and the need for a solid testing strategy for time-dependent behavior (e.g., using a mock clock) are the primary drivers of its complexity score."
		},
		{
			"taskId": 9,
			"taskTitle": "Implement Daemon IPC Server",
			"complexityScore": 5,
			"recommendedSubtasks": 3,
			"expansionPrompt": "Modify the `Daemon` struct in `internal/daemon` to include an instance of the `ipc.Server`. In the `Run()` method, start the IPC server's `Listen()` method in a separate goroutine. Implement the handler functions for grant, revoke, and status requests. These handlers will receive requests from the IPC server, modify the daemon's state (e.g., add/remove leases), and return appropriate responses. Ensure state modifications are protected by a `sync.Mutex` to prevent race conditions.",
			"reasoning": "While the heavy lifting of the IPC protocol is in Task 5, this task is complex due to its concurrent nature. It requires running the server in a goroutine and ensuring that the handlers, which are executed concurrently in response to CLI commands, can safely modify the daemon's central state without causing race conditions."
		},
		{
			"taskId": 10,
			"taskTitle": "Implement CLI IPC Client",
			"complexityScore": 3,
			"recommendedSubtasks": 2,
			"expansionPrompt": "In the `internal/ipc` package, enhance the `Client` struct. Add specific, high-level methods for each command, such as `SendGrantRequest(req GrantRequest)`, `SendRevokeRequest(req RevokeRequest)`, etc. These methods should encapsulate the logic of connecting to the daemon, sending the signed request, and decoding the response. Implement clear error wrapping to distinguish between connection errors (e.g., daemon not running) and application-level errors returned by the daemon.",
			"reasoning": "This task is relatively low complexity because the fundamental communication and security logic was built in Task 5. This task is about creating a user-friendly, high-level client-side API on top of that foundation for the CLI commands to consume, which is primarily a structural and error-handling exercise."
		},
		{
			"taskId": 11,
			"taskTitle": "Implement `env-lease grant` Command",
			"complexityScore": 4,
			"recommendedSubtasks": 3,
			"expansionPrompt": "In the `cmd` package, create a `grant.go` file. Define a new `cobra.Command` for `grant`. Add flags for `--override` and `--continue-on-error`. In the `RunE` function, implement the following logic: 1. Load the `env-lease.toml` configuration using the `config` package. 2. Create an `ipc.Client`. 3. Construct a `GrantRequest` from the loaded configuration and command flags. 4. Use the client to send the request to the daemon and print the result or error.",
			"reasoning": "This is an integration task of moderate complexity. It doesn't involve creating new core algorithms but requires correctly using and orchestrating several other packages (cobra, config, ipc) to deliver a user-facing feature. Handling command-line flags, loading configuration, and communicating with the daemon makes it a non-trivial wiring job."
		},
		{
			"taskId": 12,
			"taskTitle": "Implement `env-lease revoke` Command",
			"complexityScore": 2,
			"recommendedSubtasks": 2,
			"expansionPrompt": "In the `cmd` package, create a `revoke.go` file. Define a `cobra.Command` for `revoke`. In the `RunE` function, create an `ipc.Client`, construct a `RevokeRequest` (it will need the path to the config file to identify the project), and send it to the daemon. Print a success message or the error returned.",
			"reasoning": "This is a low-complexity task. It's a very thin wrapper around the IPC client, sending a simple, pre-defined command to the daemon. It has significantly fewer moving parts than the `grant` command as it does not need to parse the full config details itself."
		},
		{
			"taskId": 13,
			"taskTitle": "Implement `env-lease status` Command",
			"complexityScore": 3,
			"recommendedSubtasks": 3,
			"expansionPrompt": "In the `cmd` package, create a `status.go` file. Define a `cobra.Command` for `status`. In the `RunE` function, use the `ipc.Client` to send a `StatusRequest`. Upon receiving the response, use the `text/tabwriter` package to format the list of active leases, their destinations, and their remaining time-to-live (TTL) into a clean, human-readable table printed to standard output.",
			"reasoning": "This task is of low complexity. Like `revoke`, it's a simple IPC call, but with the additional requirement of formatting the structured data received from the daemon into a human-readable table. This output formatting adds a minor implementation step compared to `revoke`."
		},
		{
			"taskId": 14,
			"taskTitle": "Implement Daemon Revocation Failure Handling",
			"complexityScore": 6,
			"recommendedSubtasks": 3,
			"expansionPrompt": "Modify the daemon's revocation logic. When a revocation fails, instead of just logging, the lease should be moved to a retry queue within the daemon's state. This queue should track the number of attempts and the next scheduled retry time. Implement an exponential backoff strategy for retries. If a lease fails to be revoked for over 5 minutes, use the atomic writer utility to create a `.envrc.env-lease-REVOCATION-FAILURE` file. Ensure this new retry state is persisted along with the main daemon state.",
			"reasoning": "This task has moderate-to-high complexity because it adds sophisticated error handling and state management to the daemon's core loop. Implementing a robust retry mechanism with exponential backoff, managing the associated state, and handling persistent failure notifications requires careful changes to the existing state machine and time-based logic."
		},
		{
			"taskId": 15,
			"taskTitle": "Implement Orphaned Lease Cleanup",
			"complexityScore": 5,
			"recommendedSubtasks": 3,
			"expansionPrompt": "Add a new long-interval ticker (e.g., every 24 hours) to the daemon's main loop. On each tick, iterate through all active leases. For each lease, check if its corresponding `env-lease.toml` file still exists on disk. If not, update the lease's state with an `orphaned_since` timestamp. If a lease is already marked as orphaned, check if it has been orphaned for more than 30 days. If so, permanently revoke and remove it from the state. Also, add a hidden `env-leased --cleanup` command to trigger this check manually.",
			"reasoning": "This task is moderately complex as it introduces a new, long-running background process to the daemon. It requires adding new fields to the state model, performing periodic file I/O operations, and implementing time-based logic (the 30-day check), all of which must be integrated carefully into the existing daemon structure to avoid performance issues or bugs."
		},
		{
			"taskId": 16,
			"taskTitle": "System Service Integration (launchd for macOS)",
			"complexityScore": 4,
			"recommendedSubtasks": 3,
			"expansionPrompt": "In the `cmd` package, create a `daemon_darwin.go` file (using build tags). Add `install` and `uninstall` subcommands to a new `daemon` command. The `install` command should create a `com.user.env-leased.plist` file in `~/Library/LaunchAgents/` from a template, then use `os/exec` to run `launchctl load ...`. The `uninstall` command should run `launchctl unload ...` and remove the file.",
			"reasoning": "The complexity is moderate not because of the Go code itself (which is straightforward file writing and command execution), but because it requires specific knowledge of an external system tool (`launchctl`) and its `.plist` file format. The use of build tags to provide OS-specific implementations is a standard but slightly more advanced Go feature. Testing is also manual."
		},
		{
			"taskId": 17,
			"taskTitle": "System Service Integration (systemd for Linux)",
			"complexityScore": 4,
			"recommendedSubtasks": 3,
			"expansionPrompt": "In the `cmd` package, create a `daemon_linux.go` file (using build tags). Add `install` and `uninstall` subcommands to a new `daemon` command. The `install` command should create an `env-leased.service` file in `~/.config/systemd/user/` from a template, then use `os/exec` to run `systemctl --user enable --now ...`. The `uninstall` command should run `systemctl --user disable --now ...` and remove the file.",
			"reasoning": "Similar to the launchd task, the complexity is moderate due to the need for specific knowledge of `systemd` user services and commands. The Go code is simple, but correctly creating the service file and interacting with `systemctl` requires platform-specific expertise. It also uses build tags and requires manual testing."
		},
		{
			"taskId": 18,
			"taskTitle": "Build and Release Automation",
			"complexityScore": 4,
			"recommendedSubtasks": 3,
			"expansionPrompt": "Create a `.goreleaser.yml` file in the project root. Configure the `builds` section to create binaries for `env-lease` and `env-leased` for macOS (amd64, arm64) and Linux (amd64, arm64). Configure the `archives` and `checksum` sections. Add a `brews` section to publish a formula to a new GitHub repository that will serve as the Homebrew tap. The formula should include the service definitions for `launchd`.",
			"reasoning": "This is a configuration-heavy DevOps task that relies on external tooling. While it doesn't involve writing Go code, correctly configuring GoReleaser, especially the Homebrew tap integration which requires setting up a separate repository and formula, requires specific domain knowledge and can involve significant trial and error to get right."
		}
	]
}